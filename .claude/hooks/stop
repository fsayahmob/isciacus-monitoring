#!/bin/bash

# Hook Stop pour Claude Code
# Extrait les vraies donnÃ©es de la conversation et les sauvegarde pour le plugin VSCode

# Lire l'input JSON du hook depuis stdin
input=$(cat)

# Extraire les paramÃ¨tres
session_id=$(echo "$input" | jq -r '.session_id')
transcript_path=$(echo "$input" | jq -r '.transcript_path')
cwd=$(echo "$input" | jq -r '.cwd')
stop_hook_active=$(echo "$input" | jq -r '.stop_hook_active')

# PrÃ©venir les boucles infinies
if [ "$stop_hook_active" = "true" ]; then
  exit 0
fi

# Ã‰tendre le chemin ~ vers le rÃ©pertoire home
transcript_path="${transcript_path/#\~/$HOME}"

# VÃ©rifier que le fichier transcript existe
if [ ! -f "$transcript_path" ]; then
  echo "Error: transcript file not found at $transcript_path" >&2
  exit 1
fi

# Extraire le dernier message texte de Claude (assistant)
# Il faut chercher dans tous les content[] car content[0] peut Ãªtre un tool_use
last_claude_message=$(tac "$transcript_path" | jq -s '.[] | select(.type == "assistant") | .message.content[] | select(.type == "text") | .text' -r 2>/dev/null | head -1)
if [ -z "$last_claude_message" ]; then
  last_claude_message="<No message found>"
fi

# Conversation ID = session_id
conversation_id="$session_id"

# Extraire le nom de la conversation depuis le chemin transcript
conversation_name=$(echo "$transcript_path" | sed -E 's|.*/\.claude/projects/([^/]+)/.*|\1|')
if [ "$conversation_name" = "$transcript_path" ]; then
  conversation_name=$(basename "$cwd")
fi

# Repository name depuis git
git_dir=$(cd "$cwd" && git rev-parse --show-toplevel 2>/dev/null)
if [ $? -eq 0 ] && [ -n "$git_dir" ]; then
  repository_name=$(basename "$git_dir")
else
  repository_name=$(basename "$cwd")
fi

# Timestamp
timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

# CrÃ©er le fichier JSON pour le plugin VSCode
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CLAUDE_DIR="$(dirname "$SCRIPT_DIR")"
HOOK_DATA_FILE="$CLAUDE_DIR/hook-data.json"

# ==========================================
# DÃ‰TECTION DES ACTIONS Ã€ FAIRE
# ==========================================

# 1. VÃ©rifier git diff (fichiers modifiÃ©s non commitÃ©s)
has_changes=$(cd "$cwd" && git diff --name-only 2>/dev/null | wc -l | tr -d ' ')
has_staged=$(cd "$cwd" && git diff --staged --name-only 2>/dev/null | wc -l | tr -d ' ')

# 2. Lire le transcript pour voir ce que Claude a fait
ran_e2e=$(grep -c "npm run test:e2e" "$transcript_path" 2>/dev/null || echo "0")
ran_git_commit=$(grep -c "git commit" "$transcript_path" 2>/dev/null || echo "0")

# ==========================================
# CONSTRUIRE LE MESSAGE DYNAMIQUE
# Seulement si du code a Ã©tÃ© modifiÃ© !
# ==========================================

inject_message=""

# Ne rien injecter si aucun fichier n'a Ã©tÃ© modifiÃ©
if [ "$has_changes" -gt 0 ] || [ "$has_staged" -gt 0 ]; then
  inject_message="hook_stop: "
  inject_message+="âš ï¸ Tu as des fichiers modifiÃ©s non commitÃ©s. Fais un git add && git commit avec le bon commentaire.
"
  inject_message+="ðŸ”„ VÃ©rifie que la pipeline CI passe et ne change pas la sÃ©vÃ©ritÃ© du guard.
"

  # E2E: si pas lancÃ© dans la session â†’ demander de lancer
  if [ "$ran_e2e" -eq 0 ]; then
    inject_message+="ðŸ§ª Tu n'as pas lancÃ© les E2E. Lance: npm run test:e2e et valide le rÃ©sultat.
"
  else
    inject_message+="ðŸ§ª VÃ©rifie si les E2E doivent Ãªtre mis Ã  jour suite Ã  tes modifications.
"
  fi
fi

# ==========================================
# Ã‰CRIRE LE JSON
# ==========================================

# N'injecter que si on a quelque chose Ã  dire
if [ -n "$inject_message" ]; then
  cat > "$HOOK_DATA_FILE" <<EOF
{
  "lastMessage": $(echo "$last_claude_message" | jq -Rs .),
  "repoName": "$repository_name",
  "conversationId": "$conversation_id",
  "conversationName": "$conversation_name",
  "timestamp": "$timestamp",
  "injectMessage": $(echo "$inject_message" | jq -Rs .)
}
EOF
else
  cat > "$HOOK_DATA_FILE" <<EOF
{
  "lastMessage": $(echo "$last_claude_message" | jq -Rs .),
  "repoName": "$repository_name",
  "conversationId": "$conversation_id",
  "conversationName": "$conversation_name",
  "timestamp": "$timestamp"
}
EOF
fi

exit 0
